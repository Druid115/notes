## Redis 事务

### 定义

Redis 事务是一个单独的隔离操作：事务中所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令所打断。

Redis 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

Redis 事务的主要作用就是串联多个命令，防止别的命令插队。



### 用法

使用  **MULTI** 命令开始事务。之后输入的命令都会依次进入命令队列中，但不会执行，直到输入 **EXEC** 命令，Redis 会将队列中的命令依次执行。

组队的过程中可以使用 **DISCARD** 清空队列并退出事务。

事务中的错误：

- 事务在执行 **EXEC** 之前，入队的命令可能会出错。比如说，语法错误（参数数量错误，参数名错误等等），或者其他更严重的错误，比如内存不足（如果服务器使用 `maxmemory` 设置了最大内存限制）。

- 命令可能在 **EXEC** 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面。

对于发生在 **EXEC** 执行之前的错误，服务器会对命令入队失败的情况进行记录，并在客户端调用 **EXEC** 命令时，拒绝执行并自动放弃这个事务。

对于在 **EXEC** 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个 / 某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。

所以，Redis 的事务根本不能算**原子性**，而仅仅是满足了事务的**隔离性**，当前执行的事务有着不被其它事务打断的权利。



### 为什么 Redis 不支持回滚

- Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面。这也就是说，从实用性的角度来看，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，不应该出现在生产环境中。
- 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。



### 使用 check-and-set 操作实现乐观锁

**WATCH** 命令可以为 Redis 事务提供 check-and-set（CAS）行为。

被 **WATCH** 的键会被监视，并会检查这些键是否被改动过了。如果有至少一个被监视的键在 **EXEC** 执行之前被修改了，那么整个事务都会被取消。

~~~shell
> watch books
OK
> incr books # 被修改了
(integer) 1
> multi
OK
> incr books
QUEUED
> exec # 事务执行失败
(nil)
~~~