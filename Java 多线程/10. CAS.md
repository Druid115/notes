## CAS

### 乐观锁与悲观锁

**悲观锁**就是普通的锁。对于悲观锁来说，它认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。

**乐观锁**又称为 “无锁”，它总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为 CAS 的技术来保证线程执行的安全性。**天生免疫死锁**。

乐观锁多用于 “读多写少“ 的环境，避免频繁加锁影响性能；而悲观锁多用于 ”写多读少“ 的环境，避免频繁失败和重试影响性能。



### CAS

CAS（Compare And Swap）的全称是比较并交换，它是一条 CPU 的原子指令，从 CPU 层面保证了它的原子性。在 CAS 中，有这样三个值：

- V：要更新的变量
- E：预期值
- N：新值

比较并交换的过程如下：

判断 V 是否等于 E，如果等于，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新，什么都不做。所以这里的预期值 E 本质上指的是 “旧值”。

当多个线程同时使用 CAS 操作一个变量时，只有一个会成功更新，其余均会失败。但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试或者放弃操作。



### 三大问题

#### ABA 问题

所谓 ABA 问题，就是一个值原来是 A，变成了 B，又变回了 A。这个时候使用 CAS 是检查不出变化的，但实际上却被更新了两次。

ABA 问题的解决思路是在变量前面追加上**版本号或者时间戳**。从 JDK 1.5 开始，JDK 的 atomic 包里提供了一个AtomicStampedReference 类来解决 ABA 问题。这个类的 `compareAndSet` 方法检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用 CAS 设置为新的值和标志。



#### 循环开销时间大

CAS 多与自旋结合，如果自旋长时间不成功，会占用大量的 CPU 资源。

解决思路是让 JVM 支持处理器提供的 pause 指令。pause 指令能让自旋失败时 CPU 睡眠一小段时间再继续自旋，从而使得读操作的频率低很多，为解决内存顺序冲突而导致的 CPU 流水线重排的代价也会小很多。



#### 只能保证一个共享变量的原子操作

解决方案：

1. 使用 JDK 1.5 开始提供的 AtomicReference 类保证对象之间的原子性，把多个变量放到一个对象里面进行 CAS 操作。
2. 使用锁来控制多线程对临界区的访问。
