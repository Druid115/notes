## 指令重排与 happens-before

### 指令重排

计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。指令重排可以保证串行语义⼀致，但是没有义务保证多线程间的语义也⼀致。



### 顺序一致性模型

顺序⼀致性模型有两大特性：

- ⼀个线程中的所有操作必须按照程序的顺序（即 Java 代码的顺序）来执行。
- 不管程序是否同步，所有线程都只能看到⼀个单⼀的操作执行顺序。即每个操作必须是原子性的，且立刻对所有线程可见。

对于未同步的多线程程序，JMM 只提供最小安全性：线程读取到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。

1. 顺序⼀致性保证单线程内的操作会按程序的顺序执行；JMM 不保证单线程内的操作会按程序的顺序执行。（但 JMM 保证单线程下的重排序不影响执行结果）
2. 顺序⼀致性模型保证所有线程只能看到⼀致的操作执⾏顺序，而 JMM 不保证所有线程能看到⼀致的操作执行顺序。（因为 JMM 不保证所有操作立即可见）
3. JMM 不保证对 64 位的 long 型和 double 型变量的写操作具有原子性，而顺序⼀致性模型保证对所有的内存读写操作都具有原子性。



### happens-before

happens-before 关系的定义如下：

1. 如果⼀个操作 happens-before 另⼀个操作，那么第⼀个操作的执行结果将对第⼆个操作可见，而且第⼀个操作的执行顺序排在第⼆个操作之前。
1. 两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果⼀致，那么 JMM 也允许这样的重排序。

在 Java 中，有以下天然的 happens-before 关系：

- 程序顺序规则：在一个线程内，按照控制流顺序（非程序代码顺序，因为要考虑分支、循环等结构），每⼀个操作 happens-before于该线程中的任意后续操作。

- 监视器锁规则：对⼀个锁的解锁 happens-before 于随后对这个锁的加锁。

- volatile 变量原则：对一个 volatile 变量的写操作 happens-before 于后续对这个变量的读操作。

- 线程启动原则：Thread 对象的 `start()` 方法先行发生于此线程的每一个动作。

- 传递性：如果操作 A happens-before 操作 B，操作 B happens-before 操作 C，那么操作 A happens-before 操作 C。
