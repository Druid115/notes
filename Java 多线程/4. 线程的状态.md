## 线程的状态

### 操作系统中的线程状态

操作系统线程主要有以下三个状态： 

- 就绪状态（ready）：线程正在等待使用 CPU，经调度程序调用之后可进入 running 状态。
- 执行状态（running）：线程正在使用 CPU。
- 等待状态（waiting）：线程等待某些事件的完成或者正在等待其他资源（如 I/O）。

![操作系统中的线程状态](../images/20220211165759903.png)



### Java 线程的状态

~~~java
// Thread.State
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}
~~~

- NEW：线程此时尚未启动，指的是还没调用 Thread 实例的 `start()` 方法。

- RUNNABLE：运行状态，处于该状态的线程也有可能在等待其他系统资源（比如 I/O）。

- BLOCKED：阻塞状态，处于该状态的线程正等待锁的释放以进⼊同步区。

- WAITING：等待状态，处于该状态的线程变成 RUNNABLE 状态需要其他线程唤醒。调用如下 3 个方法会使线程进⼊等待状态
  - `Object.wait()`：使当前线程处于等待状态直到另⼀个线程唤醒它；
  - `Thread.join()`：等待线程执行完毕，底层调用的是 Object 实例的 `wait()` 方法；
  - `LockSupport.park()`：除非获得调用许可，否则禁用当前线程进行线程调度。

- TIMED_WAITING：超时等待状态，线程等待⼀个具体的时间，时间到后会被⾃动唤醒。调用如下方法会使线程进⼊超时等待状态：
  - `Thread.sleep(long millis)`：使当前线程睡眠指定时间；
  - `Object.wait(long timeout)`：线程休眠指定时间，等待期间可以通过 `notify()` / `notifyAll()` 唤醒；
  - `Thread.join(long millis)`：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会⼀直执行；
  - `LockSupport.parkNanos(long nanos)`： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；
  - `LockSupport.parkUntil(long deadline)`：同上，也是禁止线程进行调度指定时间。
- TERMINATED：终止状态，此时线程已执行完毕。

![Java 中的线程状态](../images/20220211172146828.png)



#### BLOCKED 状态与 RUNNABLE 状态的转换

~~~java
public static void blockedTest() {
    Thread a = new Thread(new Runnable() {
        @Override
        public void run() {
            testMethod();
        }
    }, "a");
    Thread b = new Thread(new Runnable() {
        @Override
        public void run() {
            testMethod();
        }
    }, "b");
    a.start();
    b.start();
    System.out.println(a.getName() + ":" + a.getState());
    System.out.println(b.getName() + ":" + b.getState());
}

private static synchronized void testMethod() {
    try {
        Thread.sleep(2000L);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
~~~

上述代码不一定会输出 a:TIMED_WAITING b:BLOCKED，原因是启动线程后执行 `run()` 方法还是需要消耗⼀定时间的，main 线程有可能在两个线程开始竞争锁之前就打印出两个线程的状态。



#### WAITING 状态与 RUNNABLE 状态的转换

- `Object.wait()`：调用 wait() 方法前线程必须持有对象的锁。线程调用 `wait()` 方法时，会释放当前的锁，直到有其他线程调用 `notify()` / `notifyAll()` 方法唤醒等待锁的线程。需要注意的是，其他线程调用 `notify()` 方法只会唤醒单个等待锁的线程，如有多个线程都在等待这个锁，不⼀定会唤醒到之前调用 `wait()` 方法的线程。同样，调用 `notifyAll()` 方法唤醒所有等待锁的线程之后，也不⼀定会马上把时间片分给刚才放弃锁的那个线程，具体要看系统的调度。
- `Thread.join()`：调用该方法不会释放锁，会⼀直等待当前线程执行完毕（转换为 TERMINATED 状态）。



