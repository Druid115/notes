### 工厂模式

#### 简单工厂模式

- 定义：由一个工厂对象决定创建出哪一种产品类的实例。
- 类型：创建型，但不属于 GOF 23种设计模式。
- 适用场景：工厂类负责创建的对象比较少，客户端（应用层）只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心。
- 优点：传入参数即可获得需要的对象，不关心具体细节。
- 缺点：工厂类集中了所有实例的创建逻辑，职责相对过重，违反了高内聚责任分配原则；增加新的产品，需要修改判断逻辑，违背了开闭原则。
- 例子：Java Calendar createCalendar 等。



#### 工厂模式

- 定义：定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。
- 适用场景：创建对象需要大量重复的代码；客户端不依赖于产品类实例如何被创建、实现等细节；一个类通过其子类来指定创建哪个对象。
- 优点：用户只需要关心所需产品对应的工厂，无须关心创建细节；专门的工厂负责创建专门的类，加入新产品符合开闭原则，提高可扩展性。
- 缺点：类的数量容易过多，增加复杂度；增加了系统的抽象性和理解难度。
- 例子：Java Collection iterator，logback 等。



#### 抽象工厂

- 定义：抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口，无须指定它们具体的类。
- 适用场景：客户端不依赖于产品类实例如何被创建、实现等细节；强调一系列相关的产品对象（属于同一产品族，产品等级比较固定，变动可能性不大或者变化频率不高）一起创建需要大量重复的代码；提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体的实现。
- 优点：具体产品在应用层代码隔离，无须关心创建细节；将同一系列的产品族统一到一起创建。
- 缺点：规定了所有可能被创建的产品集合，产品族中扩展产品很困难，需要修改抽象工厂的接口，违背开闭原则；增加了系统的抽象性和理解难度。
- 例子：Java Connection，MyBatis SqlSessionFactory 等。
