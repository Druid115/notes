## 运行时数据区

线程独有：程序计数器、栈、本地方法栈，共享：堆、堆外内存（元空间、代码缓存）。

![20201215162139067](../images/20201215162139067.png)

JVM 系统线程：

1. 这些后台线程不包括调用 public static void main(String []) 的 main 线程以及所有这个 main 线程自己创建的线程。
2. **虚拟机线程**：这种线程的操作是需要 JVM 达到安全点才会出现，这样堆才不会变化。这种线程的执行类型括 "stop-the-world" 的垃圾收集、线程栈收集、线程挂起以及偏向锁撤销。
3. **周期任务线程**：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。
4. **GC 线程**：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持。
5. **编译线程**：这种线程在运行时会将字节码编译成到本地代码。
6. **信号调度线程**：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理。



### 程序计数器

JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟，它是一块很小的内存空间，几乎可以忽略不记，也是运行速度最快的存储区域。生命周期与线程的生命周期保持一致。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行 native 方法，则是未指定值（undefned）。执行引擎将指令解释为机器码交由 CPU 进行处理。**它是唯一一个在 Java 虚拟机规范中没有规定任何 OutofMemoryError 情况的区域。**

![20201216215743607](../images/20201216215743607.png)

线程是一个个的顺序执行流，CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令，为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC 寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。